---
title: "Predição da profundidade do solum"
author: "Horst"
date: "1 de novembro de 2017"
output:
  bookdown::word_document2:
    reference_docx: ../docs/template.docx
bibliography: biblio.bib
csl: abnt.csl
lang: pt
---
```{r}
rmarkdown::render('main.Rmd', encoding = 'UTF-8', output_dir = "../docs")
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Carregar os Pacotes
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(latticeExtra)
library(georob)
library(sp)
library(mapview)
library(raster)
library(rmarkdown)
library(caret)

# Sistemas de referência de coordenadas (Fonte: http://spatialreference.org/ref/epsg/)
wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sirgas2000 <- sp::CRS('+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs')

# Rampas de cores
col_soil_var <- topo.colors(100)
```


*Caracterização dos dados*

Os dados que utilizei para este trabalho são provenientes de um povoamento florestal de 108 ha de $Pinus taeda$ L. de 29 anos. A área pertence ao município de Campo Belo do Sul, região serrana do Estado de Santa Catarina, Brasil. O clima é do tipo Cfb, mesotérmico, subtropical úmido e com precipitação média de 1.647 mm com chuvas bem distribuídas no ano. A geologia regional é constituída por uma sequência vulcânica de rochas ácidas da Formação Serra Geral, com predomínio de riodacito.

Na área de estudo foam identificados Neossolos Litólicos e Neossolos Regolíticos, Cambissolos Háplicos e Cambissolos Húmicos, Latossolos Vermelhos e Gleissolos Melânicos, os quais representam a topossequência clássica da área de estudo (Figura 1c). Conforme as tendências observadas no campo, em locais de relevo plano ou suavemente ondulado com boa drenagem estão solos profundos com sequência de horizontes A-Bw (Latossolos), em condições de má drenagem, ocorrem solos com a sequência de horizonte A-Cg (Gleissolos). Nos relevos ondulado ou fortemente ondulado, predominam solos rasos com a sequência de horizontes A ou A-Bi (Neossolos e Cambissolos).

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('../docs/figura1.png')
```

Figura 1. Localização da área de estudo no município de Campo Belo do Sul, Estado de Santa Catarina (SC), Brasil (a) e área ampliada com modelo digital de elevação e distribuição dos pontos amostrais (b). Relação da classe de solo e altura das árvores de uma Topossequência típica da área de estudo (c).


*Amostragem*

Definimos uma malha amostral contendo 102 pontos para coleta de dados (Figura 1 b). Os pontos foram alocados pelo algoritmo Hipercubo Latino Condicionado (Conditioned Latin Hipercube Sampling – cLHS) através da função $clhs()$ implementado no pacote **clhs**. Foram consideradas como variáveis condicionantes da amostragem ELEV, VD, TWI, CNBL e DECLI as quais, juntas, explicaram aproximadamente 86% da variância topográfica, identificada através da Análise de Componentes Principais (ACP).

Em cada ponto amostral foi medida a profundidade do solum (PF) e a altura das árvores (h). Consideramos solum a espessura máxima do solo onde as raízes podem se desenvolver sem impedimentos físicos para penetração livre das raízes. Os fatores limitantes considerados foram o lençol freático elevado e o contato com rocha consolidada (contato lítico) com ou sem fissuras.
Para representar h utilizamos o valor médio dos quatro indivíduos de $Pinus taeda$ mais próximos de cada ponto amostral foram mensurados. Portanto, cada ponto de amostragem representa uma área (bloco) de aproximadamente 10 x 10 metros no campo.

```{r}

pontos <- read.csv('../data/GateadosDados.csv', dec = ".", sep= ";", stringsAsFactors = FALSE)

sp :: coordinates(pontos) <- c('X' , 'Y')
sp :: proj4string(pontos) <- wgs84utm22s #coordenada referencia
pontos <- sp :: spTransform(pontos, wgs84utm22s) #transforma coordenada para wgs84

pontos@data

```

Verificar a normalidade dos dados

```{r}
stats::shapiro.test(pontos$PFd)
raster::hist(pontos$PFd)

stats::shapiro.test(pontos$h)
graphics::hist(pontos$h)

```

PF bimodal
h normal

```{r}

par(mfrow=c(1,2))

graphics::hist(pontos$PFd, breaks=10, xlab="", col="grey90", cex.axis=1,
          xlim=c(1,10),  ylim=c(0,37),ylab="",main=" ") 
    xfit<-base::seq(min(pontos$PFd),max(pontos$PFd), length=50) 
    yfit<-stats::dnorm(xfit,mean=mean(pontos$PFd),sd=sd(pontos$PFd))
   yfit<-  yfit*diff(ex$mids[1:2])*length(pontos$PFd) 
    lines(xfit, yfit, col="red", lwd=2) 
    mtext("Frequência",line=2.6, side=2, cex=1) 
    mtext("PF (dm)",line=2.6, side=1, cex=1) 
    graphics::rug((pontos$PFd), col="red")
     box()


graphics::hist(pontos$h, breaks=10, xlab="", col="grey90", cex.axis=1,
          xlim=c(23,38),  ylim=c(0,16),ylab="",main="") 
    xfit<-base::seq(min(pontos$h),max(pontos$h), length=50) 
    yfit<-stats::dnorm(xfit,mean=mean(pontos$h),sd=sd(pontos$h))
   yfit<-  yfit*diff(ex$mids[1:2])*length(pontos$h) 
    lines(xfit, yfit, col="red", lwd=2) 
    mtext("Frequência",line=2.6, side=2, cex=1) 
    mtext("h (m)",line=2.6, side=1, cex=1) 
    graphics::rug((pontos$h), col="red")
     box()
     
```


Utilizei o MDE disponibilizado pelo Governo do Estado de SC - Secretaria de Estado do Desenvolvimento Econômico Sustentável, proveniente do Levantamento Aerofotogramétrico em 2010. Os dados, disponibilizados com resolução de 1 metro, foram reamostrados para resolução espacial de 10 metros utilizando a ferramenta $reamostragem$ no software SAGA GIS.

A partir do MDE foram derivadas 12 variáveis topográficas utilizando a ferramenta $Tarrain Analyses$ do software SAGA GIS.

```{r}

ASP <- raster::raster("../data/Covars/ASP.tif")
CNBL <- raster::raster("../data/Covars/CNBL.tif")
DECLI <- raster::raster("../data/Covars/DECLI.tif")
ELEV <- raster::raster("../data/Covars/ELEV.tif")
LS <- raster::raster("../data/Covars/LS.tif")
PLC <- raster::raster("../data/Covars/PLC.tif")
RSP <- raster::raster("../data/Covars/RSP.tif")
TPI <- raster::raster("../data/Covars/TPI.tif")
TRI <- raster::raster("../data/Covars/TRI.tif")
TWI <- raster::raster("../data/Covars/TWI.tif")
VD <- raster::raster("../data/Covars/VD.tif")
VDCN <- raster::raster("../data/Covars/VDCN.tif")
RFPF <- raster::raster("../data/Covars/predictionPF.tif")
```

A partir da função `extract` implementada no pacote *raster* extraí os valores de cada objeto raster nas localizações de cada observação contidas no objeto espacial "pontos".

```{r}
pontos$ASP <- raster::extract(ASP,  pontos)
pontos$CNBL <- raster::extract(CNBL, pontos)
pontos$DECLI <- raster::extract(DECLI, pontos)
pontos$ELEV <- raster::extract(ELEV, pontos)
pontos$LS <- raster::extract(LS, pontos)
pontos$PLC <- raster::extract(PLC, pontos)
pontos$RSP <- raster::extract(RSP, pontos)
pontos$TPI <- raster::extract(TPI, pontos)
pontos$TRI <- raster::extract(TRI, pontos)
pontos$TWI <- raster::extract(TWI, pontos)
pontos$VD <- raster::extract(VD, pontos)
pontos$VDCN <- raster::extract(VDCN, pontos)
pontos$RFPF <- raster::extract(RFPF, pontos)
```

Além dos atributos do terreno, foi utilizado o mapa predito via random forest (RF) utilizando o comando `rf()` implementado no pacote *caret*, com número padrão de preditores a serem selecionados em cada nó padrão $(mtry = padrão)$ e 1000 árvores $(ntrees = 1000)$, utilizando como preditoras as variáveis topográficas oriundas do MDE

```{r}
sp::spplot(RFPF, scales = list(draw = TRUE))
```


Para fins de ordenamento de produção, a área possui 12 parcelas fixas de inventário contínuo (PIC) de 500 metros quadrados cada que são utilizados na estimativa da produtividade local.

Cada PIC é classificada em função da média de altura das 100 árvores de maior perímetro basal da parcela, expressa como altura dominante (Hdom). Em função da Hdom e seus incrimentos anuais é estabelecido o índices de sítio (IS). Esse índice é então atribuido à todo o talhão.

As parcelas da área foram classificação em 4 níveis, em que 1 corresponde ao sítio com melhor produtividade (Figura 2).

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('../docs/figura2.png')
```
Figura 2 - Área de estudo, com indicação da área produtiva e parcelas de inventário contínuo contento os índices de sítio e respectivos valores de altura dominante


Os níveis de produtividade foram atribuidos aos polígonos e, naquelas em que não existe parcela de PIC, o valor de sítio foi estimado com base na altura das árvores amostradas á campo e das PCIs vizinhas.

```{r}
pistola <- 
 raster::shapefile('../data/contorno/limite_projeto.shp',
                   stringsAsFactors = FALSE, encoding = 'UTF-8') %>%
sp::spTransform(wgs84utm22s)
```

Utilizei a função $shapefile$ implementada no pacote *raster* para carregar o polígono da área de estudo - armazenado no objeto `pistola` e o polígono com informações das sítio - armazenado no objeto `ProdutividadePistola`.
A função sp::spTransform foi usada para projetar as coordenadas original no plano cartesiano (UTM).


```{r}
ProdutividadePistola <- 
 raster::shapefile('../data/Produtividade/ProdutividadePistola.shp') %>%
 sp::spTransform(wgs84utm22s)

sp::spplot(ProdutividadePistola, main = "Mapa de índices de Sítio")
default.stringsAsFactors()
str(ProdutividadePistola)
```

Usei a função `over` implementada no pacote *sp* para identificar o nível de produtividade do polígono dentro da qual cada observação se encontra e O resultado foi armazenado em uma coluna definida como $Sitio$ no objeto mesmo objeto espacial "pontos".

```{r}
pontos$Sitio <- sp::over(x = pontos, y = ProdutividadePistola, na.omit = TRUE) %>% unlist()
pontos$Sitio <- as.factor(pontos@data$Sitio)
```

```{r}
col_sitio <- terrain.colors(nlevels(ProdutividadePistola$ProdutividadePistola))

sp::spplot(
  ProdutividadePistola, scales = list(draw = T),
  main = 'Localização dos pontos') +
  lattice::xyplot(Y ~ X, data = as.data.frame(pontos@coords),
                  pch = 20, col = 'red', lwd = 2, cex = 1.5) %>%
latticeExtra::as.layer()
```

*Parte I - Profundidade do solo*

n = 96 observações para calibração + predição + validação (108 ha)
Validação: validação cruzada (leave-one-out)

**Modelo linear misto de variação espacial (georob)**

Para utilizar esse modelo, supus que os dados são uma realização de um campo aleatório com distribuição normal que podem ser descritos como a combinação aditiva de efeitos fixos, efeitos aleatórios e erro aleatório independente.
Assim, considerei como efeitos fixos da variação da PFd a predição da PF via floresta aleatória, atributos de terreno oriundos do MDE e os índices de sítio.

**Ajuste do variograma:**

```{r fig.asp=1, fig.width=7, fig.height=7}

vario<- georob::sample.variogram(PFd ~ RFPF + ELEV + DECLI + Sitio,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, estimator = c( "matheron"),
    mean.angle = TRUE, annotate.npairs = T) %>%
  plot()

```

```{r}
lags <- seq(0, 100, length.out = 15)
georob::sample.variogram(
 PFd ~ RFPF + ELEV + DECLI, data = pontos, locations = ~ X + Y, lag.dist.def = lags,
  xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
    plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)')
```

Avaliada a evolução da semivariância nas diferentes direções, há evidência da existência de estruturas de autocorrelação espacial dependentes da direção, então o processo espacial é anisotrópico.
Porém, assumi a isotropia do processo espacial e o semivariograma amostral gerado foi independente da direção.

Ajustei ao variograma amostral um modelo exponencial do variograma usando o método dos quadrados mínimos não-lineares ponderados, com ponderação definida conforme o método de Cressie. O processo de estimativa dos parâmetros do modelo exponencial do variograma foi conduzido via otimização usando a função stats::optim(method = "BFGS").

produzidos pelo otimizador a cada 10 iterações:

```{r}
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 13, nugget = 10, scale = 70), 
  weighting.method = "cressie", method = "BFGS")


summary(vario_fit)
```

```{r}

plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
```

Na geoestatística clássica, a variância não explicada é expressa em um único parâmetro $nugget$. Porém, no modelo linear misto podemos separar o parâmetro nugget em dois componentes: a variãncia devida aos erros de medida, modelada pelo parâmetro $nugget$ e variância devida à variação espacial em pequena escala, modelada pelo parâmetro $snugget$.
Considerando que durante a obteção dos dados de campo as informações de PF os valores foram arredondadas pelas em decímetros, considerei que a variância do erro de medida é igual a 0.5, ou seja, 62% do parâmetro $nugget$. A variância restante foi atribuída a variação espacial não auto-correlacionada espacialmente - não capturada pelo plano amostral $snugget$.

Feitas essa suposição, ajustei novamente o modelo novamente, agora mantendo ambos nugget e snugget fixos.

```{r}
vario_fit_error <- georob::georob(
   PFd ~ RFPF + ELEV + DECLI, pontos, locations = ~ X + Y, variogram.model = 'RMexp', 
  param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
            nugget = vario_fit$variogram.object[[1]]$param[['nugget']] * 0.625,
            snugget = vario_fit$variogram.object[[1]]$param[['nugget']] * 0.375,
            scale = vario_fit$variogram.object[[1]]$param[['scale']]),
  fit.param = georob::default.fit.param(nugget = FALSE, snugget = FALSE),
  tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(vario_fit_error)
```

```{r}
plot(vario, type = "b", xlab = 'Distância de separação (m)', ylab = 'Semivariância', lty = 'dashed')
lines(vario_fit, col = "navyblue")
lines(vario_fit_error, col = "orange")
```

```{r}
grid <- sp::spsample(pistola, 10000, type = 'regular') #CRIAR O GRID: Suporte de predição pontual

sp::spplot(grid, scales = list(draw = TRUE))

```

Argumento type: fazer a predição do sinal "signal" z, "response" se for y ou efeitos fixos "trend"
se quiser predizer erro de medida, y = z + e, então response - signal = erro
se tendência - predito = componente aleatório

```{r}
colnames(grid@coords) <- colnames(pontos@coords) #deixar com nomes diferentes

pred_ponto <- stats::predict(
  vario_fit, newdata = grid, type= "signal", signif = 0.95)

sp::gridded(pred_ponto) <- TRUE

```