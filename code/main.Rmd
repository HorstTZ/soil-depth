---
title: "Modelagem geoestatística da profundidade do solo em área de produção silvicultural"
author: "Horst"
date: "1 de novembro de 2017"
output:
    bookdown::html_document2:
   #bookdown::word_document2:
   #  reference_docx: ../docs/template.docx
#bibliography: biblio.bib
csl: abnt.csl
lang: pt
---

```{r, echo=FALSE, eval=FALSE}
rmarkdown::render('main.Rmd', encoding = 'UTF-8', output_dir = "../docs")
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
rm(list = ls())
# Carregar os Pacotes
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(latticeExtra)
library(georob)
library(sp)
library(mapview)
library(raster)
library(rmarkdown)
library(caret)
library(randomForest)
```

# Objetivo

Realizar a modelagem geoestatística da profundidade do solum área de produção silvicultural

<!-- Não entendi porque todos as seções abaixo são subseções de 'Objetivo'.  -->
## Caracterização da área de estudo

Os dados que utilizei para este trabalho são provenientes de um povoamento florestal de 108 ha de *Pinus taeda* L. A área pertence ao município de Campo Belo do Sul, região serrana do Estado de Santa Catarina, Brasil. O clima é do tipo Cfb, mesotérmico, subtropical úmido e com precipitação média de 1.647 mm com chuvas bem distribuídas no ano. A geologia regional é constituída por uma sequência vulcânica de rochas ácidas da Formação Serra Geral, com predomínio de riodacito.

<!-- 'topossequência clássica'. Não me parece uma boa definição científica. Exceto se estiver consolidado em livros de pedologia. -->
A área possui Neossolos Litólicos e Neossolos Regolíticos, Cambissolos Háplicos e Cambissolos Húmicos, Latossolos Vermelhos e Gleissolos Melânicos, os quais representam a topossequência clássica da área de estudo (Figura 1c). Conforme as tendências observadas no campo, em locais de relevo plano ou suavemente ondulado com boa drenagem estão solos profundos com sequência de horizontes A-Bw (Latossolos), em condições de má drenagem, ocorrem solos com a sequência de horizonte A-Cg (Gleissolos). Nos relevos ondulado ou fortemente ondulado, predominam solos rasos com a sequência de horizontes A ou A-Bi (Neossolos e Cambissolos).

```{r echo=FALSE, fig.cap = "Localização da área de estudo no município de Campo Belo do Sul, Estado de Santa Catarina (SC), Brasil (a) e área ampliada com modelo digital de elevação e distribuição dos pontos amostrais (b). Relação da classe de solo e altura das árvores de uma Topossequência típica da área de estudo (c)."}
knitr::include_graphics('../docs/figura1.png')
```

## Amostragem

A coleta de dados foi realizada em 94 pontos (Figura 1 b) alocados pelo algoritmo Hipercubo Latino Condicionado *(Conditioned Latin Hipercube Sampling – cLHS)* através da função `clhs::clhs()`. Foram consideradas como variáveis condicionantes da amostragem a elevação, profundidade do vale, índice de umidade tipográfico, nivel base da rede de drenagem e declividade as quais, juntas, explicaram aproximadamente 86% da variância topográfica, identificada através da Análise de Componentes Principais (ACP).

Em cada ponto amostral foi medida a profundidade do solum (PF) e a altura total das árvores (h). Consideramos solum a espessura máxima do solo onde as raízes podem se desenvolver sem impedimentos físicos para penetração livre das raízes. Os fatores limitantes considerados foram o lençol freático elevado e o contato com rocha consolidada (contato lítico) com ou sem fissuras.

Para representar a altura das árvores utilizamos o valor médio dos quatro indivíduos de *Pinus taeda* mais próximos de cada ponto amostral. Portanto, considerando o espaçamento existente entre os indíviuos, cada ponto de amostragem representa uma área de aproximadamente 100 m^2^ no campo. Apesar do suporte amostral ser areal, considerei-os como sendo em ponto.

Os dados foram armazenados no objeto `pontos` definido como `SpatialPolygonsDataFrame` com as coordenadas projetadas em WGS84.

```{r}
pontos <- read.csv('../data/GateadosDados.csv', dec = ".", sep= ";", stringsAsFactors = FALSE)
sp :: coordinates(pontos) <- c('X' , 'Y')
wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sp :: proj4string(pontos) <- wgs84utm22s
pontos <- sp :: spTransform(pontos, wgs84utm22s)
```

Como uma análise preliminar avaliei a distribuição de frequências dos dados de profundidade do solum. 
Apesar das amostras apresentarem uma distribuição bimodal (Figura 2), visando atender aos pressupostos teóricos da geoestatística, assumi que os dados provém de uma distribuição normal.

```{r, echo = FALSE, fig.asp = 1, fig.cap=" Histograma de frequências da profundidade do solum"}
ex <- hist(pontos$PFd, breaks = 10, xlab = "", col = "grey90", cex.axis = 1, xlim = c(1, 10), ylim = c(0, 37), ylab = "", main = "")
xfit <- seq(min(pontos$PFd), max(pontos$PFd), length = 50)
yfit <- dnorm(xfit, mean = mean(pontos$PFd), sd = sd(pontos$PFd))
   yfit<-  yfit*diff(ex$mids[1:2])*length(pontos$PFd) 
    lines(xfit, yfit, col="red", lwd=2) 
    mtext("Frequência",line=2.6, side=2, cex=1) 
    mtext("PF (dm)",line=2.6, side=1, cex=1) 
    graphics::rug((pontos$PFd), col="red")
     box()
```

# Modelagem geoestatística da profundidade do  Solum

## Modelo linear misto de variação espacial

Para modelagem geoestatística dos dados foi utilizado o modelo linear misto de variação espacial $y(\boldsymbol{s}_i)$, denotado por
$$Y(\boldsymbol{s}_i) = Z(\boldsymbol{s}_i) + \varepsilon(\boldsymbol{s}_i) = \boldsymbol{x}(\boldsymbol{s}_i)^\text{T}\boldsymbol{\beta} + B(\boldsymbol{s}_i) + \varepsilon(\boldsymbol{s}_i)$$
Para utilizar esse modelo foi necessário supor que os dados são uma realização de um campo aleatório $Y(\boldsymbol{s}_i)$ com distribuição normal que podem ser descritos como a combinação aditiva de efeitos fixos, efeitos aleatórios e erro aleatório independente.

$Z(\boldsymbol{s}_i)$ ou sinal possui dois componentes. O primeiro (efeito fixo) $\boldsymbol{x}(\boldsymbol{s}_i)^\text{T}\boldsymbol{\beta}$ representa os efeitos de origem desterminística, que relaciona a dependência entre a variável e as covariáveis.

O segundo componente do sinal (efeito aleatório), $B(\boldsymbol{s}_i)$, um campo aleatório Gaussiano estacionário não-observável, descrito por sua função de média e função de covariância.

$\varepsilon(\boldsymbol{s}_i)$ é o erro (ou ruído), descrito por uma distribuição Gaussina de probabilidade, cujo parâmetro desconhecido de escala é $\tau$. 

### Efeito fixo

Defini o efeito fixo do modelo ($\boldsymbol{x}(\boldsymbol{s}_i)^\text{T}\boldsymbol{\beta}$) como sendo a profundidade do solum predita via floresta aleatória.

#### Predição via floresta aleatória

As covariáveis utilizadas na predição via floresta aleatória foram **covariáveis topográficas** e uma **covariável de produção**.

##### Covariáveis topográficas

As covariáveis topográfricas foram derivadas do modelo digital de elevação disponibilizado pelo Governo do Estado de SC - Secretaria de Estado do Desenvolvimento Econômico Sustentável, proveniente do Levantamento Aerofotogramétrico em 2010. Os dados, disponibilizados com resolução de 1 metro, foram reamostrados para resolução espacial de 10 metros utilizando a ferramenta *reamostragem* no software SAGA GIS.

Os planos de informação utilizados foram importados pela ferramenta `raster::raster`e armazenados em objetos no formato `RasterLayer` (Figura 3).

```{r, message=FALSE}
DECLI <- raster::raster("../data/Covars/DECLI.tif")
ELEV <- raster::raster("../data/Covars/ELEV.tif")
TWI <- raster::raster("../data/Covars/TWI.tif")
VD <- raster::raster("../data/Covars/VD.tif")
```

```{r, fig.asp=1, echo=FALSE, fig.cap = " Covariáveis topográficas utilizadas como preditoras no modelo floresta aleatória"}
par(mfrow=c(2,2))
plot(ELEV, main='Elevação') 
plot(DECLI,main='Declividade')
plot(TWI, main='Índice de umidade topográfico')
plot(VD, main='Profundidade do vale')
```

A partir da função `raster::extract` extraí os valores de cada objeto `RasterLayer` na localização de cada observação contida no objeto espacial `pontos`.

```{r}
pontos$DECLI <- raster::extract(DECLI, pontos)
pontos$ELEV <- raster::extract(ELEV, pontos)
pontos$TWI <- raster::extract(TWI, pontos)
pontos$VD <- raster::extract(VD, pontos)
```

##### Covariável de produção

Além dos atributos de terreno, foi utilizado um índice de produtividade disponibilizado pela empresa.

Esses índices são utilizados para ordenamento da produção e provém da amostragem de parcelas fixas. A área possui 12 parcelas fixas de inventário contínuo (PIC) de 500 metros quadrados cada que são utilizados na estimativa da produtividade local.
Cada PIC é classificada em função da média de altura das 100 árvores de maior perÍmetro basal da parcela, expressa como altura dominante (Hdom). Em função da Hdom e seus incrimentos anuais é estabelecido o índices de sítio (Sitio). Esse índice então é então atribuido à todo o talhão.

As parcelas da área são classificadas em 4 níveis, em que 1 corresponde a melhor e 4 a pior produtividade (Figura 4).

Utilizei a função `raster::shapefile` para carregar o polígono com informações das sítio - armazenado no objeto `ProdutividadePistola`.
A função `sp::spTransform` foi usada para projetar as coordenadas original no plano cartesiano (UTM) e a função `raster::extract` para extraír os valores de cada objeto raster nas localizações de cada observação contidas no objeto espacial `pontos`.

```{r, }
Sitio <- raster::raster("../data/Covars/Sitio.tif")
Sitio <- as.factor(Sitio)
sp::proj4string(Sitio) <- wgs84utm22s
pontos$Sitio <- raster::extract(Sitio, pontos) %>%  as.factor()
```

```{r, fig.cap = " Classificação dos sítios e  localização dos pontos na área de estudo"}
ProdutividadePistola <- 
 raster::shapefile('../data/Produtividade/ProdutividadePistola.shp') %>%
 sp::spTransform(wgs84utm22s)
ProdutividadePistola$Sitio <- as.factor(ProdutividadePistola$Sitio)

sp::spplot(
  ProdutividadePistola, scales = list(draw = T),
  main = 'Classificação dos sítios e  localização dos pontos') +
  lattice::xyplot(Y ~ X, data = as.data.frame(pontos@coords),
                  pch = 20, col = 'red', lwd = 2, cex = 1.5) %>%
latticeExtra::as.layer()
```

<!-- Talvez cinco níveis seja um pouco exagerado. -->
##### Construção do modelo de predição e predição espacial

Foi construído um modelo de predição através da função `carret::train(method = "rf")` que foi armazenado no objeto `rf_fit`. As variáveis topograficas e a variável de produtividade foram utilizadas como covariávies preditoras. Todas as informações foram utilizadas foram extraídas do objeto espacial `pontos`.

```{r}
rf_fit <- caret::train((PFd ~ DECLI + ELEV + Sitio), data = pontos@data, method = "rf", tuneLength = 1, ntree = 1000, importance = TRUE, na.action = na.omit, trControl = trainControl("LOOCV"))
rf_fit
```

O resultado da predição foi armazenado na coluna `rf` no objeto espacial `pontos` e o ajuste entre os dados preditos e observados estão na figura 5.

```{r lm-residuos, fig.cap=" Ajuste de dados preditos e observados"}
par <- par(mfrow = c(2,2))
pontos@data$rf <- rf_fit$finalModel$predicted
lm(PFd ~ rf, data = pontos) %>% plot()
```

O modelo `rf_fit` foi utilizado para fazer a predição espacial em toda área de estudo através da função `raster::predict` (Figura 6).

```{r, message=FALSE, warning=FALSE, fig.cap=" Mapa de profundidade do solum predito pelo modelo floresta aleatória"}
beginCluster()
prediction <- 
  clusterR(brick(DECLI, ELEV, Sitio), raster::predict, 
           args = list(model = rf_fit, type = "raw", index = 1))
endCluster()
plot(prediction, main = 'Mapa predito de profundidade do solum (dm)')
```

O RasterLayer `Sitio` possuia alguns `NA` (pixel sem valor), logo, a predição não foi realizada nesses pontos. Assim, excluí do RasterLayer `prediction` todos os pixels sem valor, através da função `na.exclude`.

O resultado dessa predição espacial foi utilizado como efeito fixo do modelo linear misto de variação.
```{r}
na.exclude(prediction)
```

## Variograma amostral

O variograma amostral (Figura 7) foi computado através da função `georob::sample.variogram`. O estimador para semivariãncia foi Metheron (método dos momentos).
Para a obtenção dos parâmetros utilizei um corte de 66% da distância máxima entre os pontos, armazenada no objeto `distmax`, excluindo os pares de longo alcance.

```{r fig.asp=1, fig.width=7, fig.height=7, fig.cap=" Variograma amostral"}
distmax <-dist(pontos@coords) %>% max() /3

limites <- seq(0, distmax, length.out = 20)
vario<- georob::sample.variogram(PFd ~ rf,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, estimator = "matheron") %>%
  plot(ylab = 'Seminvariância', xlab = 'Distância de separação (m)', annotate.npairs = TRUE, main = "Semivariograma")
```

## Ajuste da função que descreve o varigrama amostral

O método de ajuste empregado no variograma amostral foi o de quadrados mínimos não-lineares ponderados, com ajuste de um modelo exponencial, com ponderação definida conforme o método de "Cressie". O processo de estimativa dos parâmetros do modelo exponencial do variograma foi conduzido via otimização usando a função `stats::optim(method = "BFGS")`.
A função resultante desse processo foi armazenada no objeto `vario_fit`.

```{r}
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 10, nugget = 5, scale = 70), weighting.method = "cressie", method = "BFGS")
summary(vario_fit)
```

O ajuste do modelo exponencial ao variograma amostral é mostrado na Figura 8. A curva ajustada passa próximo ao centro de massa dos vinte pontos do variograma amostral.

```{r, asp = 1, fig.cap=" Variograma amostral (em preto) e função exponencial a ele ajustado (vermelho)"}
plot(vario, xlab = 'Distância de separação (m)', ylab = 'Semivariância', annotate.npairs = TRUE)
lines(vario_fit, col = "red", lty = 'dashed')
```

Considerando que durante a obteção dos dados de campo as informações de profundidade do solum os valores foram obtidos em decímetros, considerei que a variância do erro de medida é igual a 0,5 dm devido ao arredondamento dos valores.

Assim, foi possível discretizar a variância não explicada em erro de medida corresponde 0,25 do parâmetro `nugget`. A variância restante foi atribuída a variação espacial não auto-correlacionada espacialmente - não capturada pelo plano amostral `snugget`.
A função resultante desse processo foi armazenado no objeto `vario_fit_error`.

```{r, warning=FALSE}
vario_fit_error <- georob::georob(
   PFd ~ rf, pontos, locations = ~ X + Y, variogram.model = 'RMexp', 
 param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
           nugget = 0.25,
           snugget = vario_fit$variogram.object[[1]]$param[['nugget']]-0.25,
           scale = vario_fit$variogram.object[[1]]$param[['scale']]),
 fit.param = georob::default.fit.param(nugget = FALSE, snugget = FALSE),
 tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(vario_fit_error)
```

A comparação entre as funções `vario_fit_error` e `vario_fit` está na figura 9.

```{r, fig.cap=" Variograma amostral (em preto) do modelo linear da profundidade do solum e a função exponencial a ele ajustada (azul) e a função ajustada com erro de medida fixo"}
plot(vario)
lines(vario_fit, col = "blue")
lines(vario_fit_error, col = "red")
```

A função `vario_fit_error` foi utilizada para a predição espacial.
Para isso foi criado um grid de predição `grid`.
A partir da função `raster::extract` foram extraídos os valores do objeto `prediction` para o `grid`.

```{r}
grid <- sp::spsample(ProdutividadePistola, 10000, type = 'regular')
grid$rf <- raster::extract(prediction, grid)

grid<- 
  sp::SpatialPointsDataFrame(
    coords = grid@coords, 
    data = data.frame(grid),
    proj4string = grid@proj4string)
colnames(grid@coords) <- colnames(pontos@coords)
```

## Predição espacial da resposta

```{r,warning=FALSE,  fig.cap= "Mapas de predição - saída extendida do georob"}
pred_ponto <- predict(
  vario_fit_error, newdata = grid, type= "response", signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
spplot(pred_ponto)
```


```{r, fig.cap= " Mapa predito de profundidade do solum (dm)"}
sp::spplot(pred_ponto, zcol = 'pred', main = "Mapa predito de profundidade do solum (dm)")
```

### Cross-validation

```{r}
validacao <- georob::cv(vario_fit_error, nset = 93)
summary(validacao)
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / sum((validacao$pred$data - mean(validacao$pred$data))^2)
plot(validacao)
```
