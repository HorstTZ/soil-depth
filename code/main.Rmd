---
title: "Modelagem geoestatística da profundidade do solo em área de produção silvicultural"
author: "Horst"
date: "1 de novembro de 2017"
output:
    bookdown::html_document2:
   #bookdown::word_document2:
   #  reference_docx: ../docs/template.docx
#bibliography: biblio.bib
csl: abnt.csl
lang: pt
---

```{r, echo=FALSE, eval=FALSE}
rmarkdown::render('main.Rmd', encoding = 'UTF-8', output_dir = "../docs")
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
rm(list = ls())
# Carregar os Pacotes
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(latticeExtra)
library(georob)
library(sp)
library(mapview)
library(raster)
library(rmarkdown)
library(caret)
library(randomForest)
```

#Objetivo:
Realizar a modelagem geoestatística da profundidade do solum e da altura total das árvores de um povoamento florestal de *Pinus taeda*

##Caracterização da área de estudo

Os dados que utilizei para este trabalho são provenientes de um povoamento florestal de 108 ha de *Pinus taeda* L. de 29 anos. A área pertence ao município de Campo Belo do Sul, região serrana do Estado de Santa Catarina, Brasil. O clima é do tipo Cfb, mesotérmico, subtropical úmido e com precipitação média de 1.647 mm com chuvas bem distribuídas no ano. A geologia regional é constituída por uma sequência vulcânica de rochas ácidas da Formação Serra Geral, com predomínio de riodacito.

Na área foram identificados Neossolos Litólicos e Neossolos Regolíticos, Cambissolos Háplicos e Cambissolos Húmicos, Latossolos Vermelhos e Gleissolos Melânicos, os quais representam a topossequência clássica da área de estudo (Figura 1c). Conforme as tendências observadas no campo, em locais de relevo plano ou suavemente ondulado com boa drenagem estão solos profundos com sequência de horizontes A-Bw (Latossolos), em condições de má drenagem, ocorrem solos com a sequência de horizonte A-Cg (Gleissolos). Nos relevos ondulado ou fortemente ondulado, predominam solos rasos com a sequência de horizontes A ou A-Bi (Neossolos e Cambissolos).

```{r echo=FALSE, fig.cap = "1 Localização da área de estudo no município de Campo Belo do Sul, Estado de Santa Catarina (SC), Brasil (a) e área ampliada com modelo digital de elevação e distribuição dos pontos amostrais (b). Relação da classe de solo e altura das árvores de uma Topossequência típica da área de estudo (c)."}
knitr::include_graphics('../docs/figura1.png')
```

##Amostragem

A coleta de dados foi realizada em 102 pontos (Figura 1 b) alocados pelo algoritmo Hipercubo Latino Condicionado *(Conditioned Latin Hipercube Sampling – cLHS)* através da função `clhs::clhs()`. Foram consideradas como variáveis condicionantes da amostragem a elevação, profundidade do vale, índice de umidade tipográfico, nivel base da rede de drenagem e declividade as quais, juntas, explicaram aproximadamente 86% da variância topográfica, identificada através da Análise de Componentes Principais (ACP).

Em cada ponto amostral foi medimos a profundidade do solum (PF) e a altura total das árvores (h). Consideramos solum a espessura máxima do solo onde as raízes podem se desenvolver sem impedimentos físicos para penetração livre das raízes. Os fatores limitantes considerados foram o lençol freático elevado e o contato com rocha consolidada (contato lítico) com ou sem fissuras.

Para representar a altura das árvores utilizamos o valor médio dos quatro indivíduos de *Pinus taeda* mais próximos de cada ponto amostral. Portanto, considerando o espaçamento existente entre os indíviuos, cada ponto de amostragem representa uma área de aproximadamente 100 m^2^ no campo.

Os dados foram armazenados no objeto `pontos` definido como `SpatialPolygonsDataFrame` com as coordenadas projetadas em WGS84.

```{r}
pontos <- read.csv('../data/GateadosDados.csv', dec = ".", sep= ";", stringsAsFactors = FALSE)
sp :: coordinates(pontos) <- c('X' , 'Y')
wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sp :: proj4string(pontos) <- wgs84utm22s
pontos <- sp :: spTransform(pontos, wgs84utm22s)
```

Com uma análise preliminar avaliei a distribuição de freqüências dos dados de profundidade do solum e altura das árvores. 
Apesar das amostras de profundidade do solum apresentarem uma distribuição bimodal (FIgura 2), visando ao atendimento de restrições teóricas ao emprego da geoestatística, assumi que os dados provém de uma distribuição normal.

```{r, echo = FALSE, fig.asp = 1, fig.cap="2 Histograma de frequências da profundidade do solum"}
ex <- hist(pontos$PFd, breaks = 10, xlab = "", col = "grey90", cex.axis = 1, xlim = c(1, 10), ylim = c(0, 37), ylab = "", main = "")
xfit <- seq(min(pontos$PFd), max(pontos$PFd), length = 50)
yfit <- dnorm(xfit, mean = mean(pontos$PFd), sd = sd(pontos$PFd))
   yfit<-  yfit*diff(ex$mids[1:2])*length(pontos$PFd) 
    lines(xfit, yfit, col="red", lwd=2) 
    mtext("Frequência",line=2.6, side=2, cex=1) 
    mtext("PF (dm)",line=2.6, side=1, cex=1) 
    graphics::rug((pontos$PFd), col="red")
     box()
```
Os dados de altura da árvores apresentaram uma distribuição de frequências próxima a distribuição normal (Figura 3)

```{r, echo = FALSE, fig.asp = 1, fig.cap="3 Histograma de frequências da profundidade do solum"}
ex2 <- graphics::hist(pontos$h, breaks=10, xlab="", col="grey90", cex.axis=1,
          xlim=c(23,38),  ylim=c(0,16),ylab="",main="") 
    xfit<-base::seq(min(pontos$h),max(pontos$h), length=50) 
    yfit<-stats::dnorm(xfit,mean=mean(pontos$h),sd=sd(pontos$h))
   yfit<-  yfit*diff(ex2$mids[1:2])*length(pontos$h) 
    lines(xfit, yfit, col="red", lwd=2) 
    mtext("Frequência",line=2.6, side=2, cex=1) 
    mtext("h (m)",line=2.6, side=1, cex=1) 
    graphics::rug((pontos$h), col="red")
     box()
```
##Modelo geoestatístico

Para modelagem geoestatística dos dados foi utilizado o modelo linear misto de variação espacial $y(\boldsymbol{s}_i)$, denotado por
$$Y(\boldsymbol{s}_i) = Z(\boldsymbol{s}_i) + \varepsilon(\boldsymbol{s}_i) = \boldsymbol{x}(\boldsymbol{s}_i)^\text{T}\boldsymbol{\beta} + B(\boldsymbol{s}_i) + \varepsilon(\boldsymbol{s}_i)$$
Para utilizar esse modelo, foi necessário supor que os dados são uma realização de um campo aleatório $Y(\boldsymbol{s}_i)$ com distribuição normal que podem ser descritos como a combinação aditiva de efeitos fixos, efeitos aleatórios e erro aleatório independente.

$Z(\boldsymbol{s}_i)$ é o chamado sinal e possui dois componentes. O primeiro (efeito fixo) $\boldsymbol{x}(\boldsymbol{s}_i)^\text{T}\boldsymbol{\beta}$ representa os efeitos fixos de origem desterminística, que relaciona a dependência entre a variável e as covariáveis.

O segundo componente do sinal (efeito aleatório), $B(\boldsymbol{s}_i)$, representa os efeitos aleatórios, especificamente, um campo aleatório Gaussiano estacionário não-observável, descrito por sua função de média e função de covariância.

$\varepsilon(\boldsymbol{s}_i)$ é um erro (ou ruído), descrito por uma distribuição Gaussina de probabilidade, cujo parâmetro desconhecido de escala é $\tau$. 


#PARTE I - Modelagem geoestatística da profundidade do  Solum

##Modelo linear Misto de variação Espacial

###Efeito fixo

Defini o efeito fixo do modelo ($\boldsymbol{x}(\boldsymbol{s}_i)^\text{T}\boldsymbol{\beta}$) como sendo a profundidade do solum predita via floresta aleatória.

As covariáveis utilizadas na predição via floresta aleatória foram **covariáveis topográficas** e uma **covariável de produção**.

####Covariáveis topográficas

As covariáveis topográfricas foram derivadas do modelo digital de elevação disponibilizado pelo Governo do Estado de SC - Secretaria de Estado do Desenvolvimento Econômico Sustentável, proveniente do Levantamento Aerofotogramétrico em 2010. Os dados, disponibilizados com resolução de 1 metro, foram reamostrados para resolução espacial de 10 metros utilizando a ferramenta *reamostragem* no software SAGA GIS.

Os planos de informação foram importados pela ferramenta `raster::raster`e armazenados em objetos no formato `RasterLayer`.

```{r, message=FALSE}
DECLI <- raster::raster("../data/Covars/DECLI.tif")
ELEV <- raster::raster("../data/Covars/ELEV.tif")
TWI <- raster::raster("../data/Covars/TWI.tif")
VD <- raster::raster("../data/Covars/VD.tif")
```

```{r, fig.asp=1, echo=FALSE, fig.cap = "2 Covariáveis topográficas utilizadas como preditoras no modelo floresta aleatória"}
par(mfrow=c(2,2))
plot(ELEV, main='Elevação') 
plot(DECLI,main='Declividade')
plot(TWI, main='Índice de umidade topográfico')
plot(VD, main='Profundidade do vale')
```

A partir da função `raster::extract` foram extraídos os valores de cada objeto `RasterLayer` na localização de cada observação contida no objeto espacial `pontos`.

```{r}
pontos$DECLI <- raster::extract(DECLI, pontos)
pontos$ELEV <- raster::extract(ELEV, pontos)
pontos$TWI <- raster::extract(TWI, pontos)
pontos$VD <- raster::extract(VD, pontos)
```

####Covariável de produção

Além dos atributos de terreno, foi utilizado um índice de produtividade disponibilizado pela empresa como variável preditora do modelo floresta aleatória.

Esses índices são utilizados para ordenamento da produção. A área possui 12 parcelas fixas de inventário contínuo (PIC) de 500 metros quadrados cada que são utilizados na estimativa da produtividade local.
Cada PIC é classificada em função da média de altura das 100 árvores de maior perÍmetro basal da parcela, expressa como altura dominante (Hdom). Em função da Hdom e seus incrimentos anuais é estabelecido o índices de sítio (Sitio). Esse índice então é então atribuido à todo o talhão.

As parcelas da área foram classificadas em 4 níveis, em que 1 corresponde a melhor e 4 a pior produtividade. Esses níveis foram atribuidos aos polígonos e, naquelas em que não existe parcela de PIC, o valor de sítio foi estimado com base na altura das árvores amostradas á campo.

Utilizei a função `raster::shapefile` para carregar o polígono com informações das sítio - armazenado no objeto `ProdutividadePistola`.
A função `sp::spTransform` foi usada para projetar as coordenadas original no plano cartesiano (UTM) e a função `raster::extract` para extraír os valores de cada objeto raster nas localizações de cada observação contidas no objeto espacial `pontos`.

```{r, }
Sitio <- raster::raster("../data/Covars/Sitio.tif")
Sitio <- as.factor(Sitio)
sp::proj4string(Sitio) <- wgs84utm22s
pontos$Sitio <- raster::extract(Sitio, pontos) %>%  as.factor()
```

```{r, fig.cap = "3 Classificação dos sítios e  localização dos pontos na área de estudo"}
ProdutividadePistola <- 
 raster::shapefile('../data/Produtividade/ProdutividadePistola.shp') %>%
 sp::spTransform(wgs84utm22s)
ProdutividadePistola$Sitio <- as.factor(ProdutividadePistola$Sitio)

sp::spplot(
  ProdutividadePistola, scales = list(draw = T),
  main = 'Classificação dos sítios e  localização dos pontos') +
  lattice::xyplot(Y ~ X, data = as.data.frame(pontos@coords),
                  pch = 20, col = 'red', lwd = 2, cex = 1.5) %>%
latticeExtra::as.layer()
```

####Predição via floresta aleatória

Foi construido um modelo de predição armazenado no objeto `rf_fit` criado através da função `carret::train(method = "rf")`. As variáveis topograficas e a variável de produtividade foram utilizadas como covariávies preditoras. Todas as informações foram extraídas do objeto espacial `pontos`.

```{r}
rf_fit <- caret::train((PFd ~ DECLI + ELEV + Sitio), data = pontos@data, method = "rf", tuneLength = 1, ntree = 1000, importance = TRUE, na.action = na.omit, trControl = trainControl("LOOCV"))
rf_fit
```

O resultado da predição foi armazenado na coluna `rf` no objeto espacial `pontos` e o ajuste entre os dados preditos e observados estão na figura 4.

```{r lm-residuos, fig.cap="4 Ajuste de dados preditos e observados"}
par <- par(mfrow = c(2,2))
pontos@data$rf <- rf_fit$finalModel$predicted
lm(PFd ~ rf, data = pontos) %>% plot()
```

O modelo `rf_fit` foi utilizado para fazer a predição espacial em toda área de estudo através da função `raster::predict`. O resultado dessa predição espacial foi utilizado como efeito fixo do modelo linear misto de variação.

```{r, message=FALSE, fig.cap="5 Mapa de profundidade do solum predito pelo modelo floresta aleatória"}
beginCluster()
prediction <- 
  clusterR(brick(DECLI, ELEV, Sitio), raster::predict, 
           args = list(model = rf_fit, type = "raw", index = 1))
endCluster()
plot(prediction, main = 'Mapa predito de profundidade do solum (dm)')
```

#Modelagem geoestatística

Para proceder as análises geoestatístcas, assimi a estacionariedade de ordem 2, intrínseca e de isotropia.

##Variograma amostral

O variograma amostral foram computado através da função `georob::sample.variogram(method"metheron"`. O estimador para semivariãncia foi Metheron (método dos momentos).
Para a obtenção dos parâmetros foi utilizado um corte de 66% da distância máxima entre os pontos, armazenada no objeto `distmax`, excluindo os pares de longo alcance.

```{r fig.asp=1, fig.width=7, fig.height=7, fig.cap="6 Variograma amostral"}
distmax <-dist(pontos@coords) %>% max() /3

limites <- seq(0, distmax, length.out = 20)
vario<- georob::sample.variogram(PFd ~ rf,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, estimator = "matheron") %>%
  plot(ylab = 'Seminvariância', xlab = 'Distância de separação (m)', annotate.npairs = TRUE, main = "Semivariograma")
```

###Ajuste da função que descreve o varigrama amostral

O método de ajuste empregado no variograma amostral foi o de quadrados mínimos não-lineares ponderados, com ajuste de um modelo exponencial, com ponderação definida conforme o método de "Cressie". O processo de estimativa dos parâmetros do modelo exponencial do variograma foi conduzido via otimização usando a função `stats::optim(method = "BFGS")`.
A função resultante desse processo foi armazenada no objeto `vario_fit`.

```{r}
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 10, nugget = 5, scale = 70), weighting.method = "cressie", method = "BFGS")
summary(vario_fit)
```

O ajuste do modelo exponencial ao variograma amostral é mostrado na Figura 7. A curva ajustada passa próximo ao centro de massa dos vinte pontos do variograma amostral.

```{r, asp = 1, fig.cap="7 Variograma amostral (em preto) e função exponencial a ele ajustado (vermelho)"}
plot(vario, xlab = 'Distância de separação (m)', ylab = 'Semivariância', annotate.npairs = TRUE)
lines(vario_fit, col = "red", lty = 'dashed')
```

Considerando que durante a obteção dos dados de campo as informações de profundidade do solum os valores foram obtidos em decímetros, considerei que a variância do erro de medida é igual a 0,5 dm devido ao arredondamento dos valores.

Assim, foi possível discretizar a variância não explicada em erro de medida corresponde 0,25 do parâmetro `nugget`. A variância restante foi atribuída a variação espacial não auto-correlacionada espacialmente - não capturada pelo plano amostral `snugget`.
A função resultante desse processo foi armazenado no objeto `vario_fit_error`.

```{r, warning=FALSE}
vario_fit_error <- georob::georob(
   PFd ~ rf, pontos, locations = ~ X + Y, variogram.model = 'RMexp', 
 param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
           nugget = 0.25,
           snugget = vario_fit$variogram.object[[1]]$param[['nugget']]-0.25,
           scale = vario_fit$variogram.object[[1]]$param[['scale']]),
 fit.param = georob::default.fit.param(nugget = FALSE, snugget = FALSE),
 tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(vario_fit_error)
```

A comparação entre as funções `vario_fit_error` e `vario_fit` está na figura 8.

A função `vario_fit_error` foi utilizada para a predição espacial.

```{r, fig.cap=" 8 Variograma amostral (em preto) do modelo linear da profundidade do solum e a função exponencial a ele ajustada (azul) e a função ajustada com erro de medida fixo"}
plot(vario)
lines(vario_fit, col = "blue")
lines(vario_fit_error, col = "red")
```


```{r}
grid <- sp::spsample(ProdutividadePistola, 10000, type = 'regular')
colnames(grid@coords) <- colnames(pontos@coords)
```

```{r}
grid$PFprediction <- raster::extract(prediction, grid)

prediction@data

grid<- 
  sp::SpatialPointsDataFrame(
    coords = grid@coords, 
    data = data.frame(grid),
    proj4string = grid@proj4string)
colnames(grid@coords) <- colnames(pontos@coords)
```

Argumento type: fazer a predição do sinal "signal" z, "response" se for y ou efeitos fixos "trend"
se quiser predizer erro de medida, y = z + e, então response - signal = erro
se tendência - predito = componente aleatório


Usar control.predict.georob(extended.output = TRUE)
```{r}
pred_ponto <- predict(vario_fit_error, newdata = grid, control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
sp::spplot(pred_ponto)
```


```{r}
pred_ponto <- predict(vario_fit_error, newdata = grid, control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
sp::spplot(pred_ponto)
```

```{r}
at <- pred_ponto@data[, c("pred", "lower", "upper")] %>% range()
at <- seq(at[1], at[2], length.out = 20)
sp::spplot(pred_ponto, zcol = c("lower", "pred", "upper"), at = at, main = "prediction")
```


```{r, warning=FALSE}
pred_ponto <- predict(
  vario_fit_error, newdata = grid, type= "response", signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE

at <- pred_ponto@data[, c("pred", "lower", "upper")]
at <- seq(at[1], at[2], length.out = 20)
sp::spplot(pred_ponto, zcol = c("lower", "pred", "upper"),  at = at, main = "prediction")
```

Componente aleatório

```{r}
sp::spplot(pred_ponto, zcol = 'se', main = "SE")
```

```{r}

validacao <- georob::cv(vario_fit_error, nset = 93)
summary(validacao)
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / sum((validacao$pred$data - mean(validacao$pred$data))^2)
plot(validacao)
```


#Parte II - Modelagem geoestatística da Altura das árvores

##Modelo linear misto de variação espacial

###Modelos fixos

Considerei como efeitos fixos da variação da h a predição da profundidade do solum via floresta aleatória.

##Ajuste do variograma amostral

```{r fig.asp=1, fig.width=7, fig.height=7}
distmax <-dist(pontos@coords) %>% max() /2

limites <- seq(0, distmax, length.out = 20)
vario<- georob::sample.variogram(h ~ DECLI,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, estimator = "matheron") %>%
  plot(ylab = 'Seminvariância', xlab = 'Distância de separação (m)', annotate.npairs = TRUE)

```

```{r}
lags <- seq(0, distmax, length.out = 12)
georob::sample.variogram(
 h ~ DECLI, data = pontos, locations = ~ X + Y, lag.dist.def = lags,
  xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180)) %>% 
    plot(type = "b", ylab = 'Semivariância', xlab = 'Distância de separação (km)')
```

Avaliada a evolução da semivariância nas diferentes direções, há evidência da existência de estruturas de autocorrelação espacial dependentes da direção, então o processo espacial é anisotrópico.
Porém, assumi a isotropia do processo espacial e o semivariograma amostral gerado foi independente da direção.

Ajustei ao variograma amostral um modelo exponencial do variograma usando o método dos quadrados mínimos não-lineares ponderados, com ponderação definida conforme o método de Cressie. O processo de estimativa dos parâmetros do modelo exponencial do variograma foi conduzido via otimização usando a função stats::optim(method = "BFGS").

produzidos pelo otimizador a cada 10 iterações:

```{r}
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 9, nugget = 2, scale = 7), weighting.method = "cressie", method = "BFGS")


summary(vario_fit)
```

```{r, ASP = 1}
plot(vario, xlab = 'Distância de separação (m)', ylab = 'Semivariância')
lines(vario_fit, col = "red", lty = 'dashed')
```

Na geoestatística clássica, a variância não explicada é expressa em um único parâmetro `nugget`. Porém, no modelo linear misto podemos separar o parâmetro nugget em dois componentes: a variãncia devida aos erros de medida, modelada pelo parâmetro `nugget` e variância devida à variação espacial em pequena escala, modelada pelo parâmetro `snugget`.
Considerando que durante a obteção dos dados de campo as informações de PF os valores foram arredondadas pelas em decímetros, considerei que a variância do erro de medida é igual a 0.5, ou seja, 62% do parâmetro `nugget`. A variância restante foi atribuída a variação espacial não auto-correlacionada espacialmente - não capturada pelo plano amostral `snugget`.


```{r}
vario_fit_error <- georob::georob(
   h ~ DECLI, pontos, locations = ~ X + Y, variogram.model = 'RMexp', 
 param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
           nugget = vario_fit$variogram.object[[1]]$param[['nugget']]*0.66,
           snugget = vario_fit$variogram.object[[1]]$param[['nugget']]*0.33,
           scale = vario_fit$variogram.object[[1]]$param[['scale']]),
 fit.param = georob::default.fit.param(nugget = FALSE, snugget = FALSE),
 tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(vario_fit_error)
```
```{r}
plot(vario)
lines(vario_fit_error)
```


CRIAR O GRID: Suporte de predição pontual
 
```{r}
grid <- sp::spsample(ProdutividadePistola, 10000, type = 'regular')
colnames(grid@coords) <- colnames(pontos@coords)
```

```{r}
grid$DECLI <- raster::extract(DECLI, grid)
grid
```

```{r}
grid <- 
  sp::SpatialPointsDataFrame(
    coords = grid@coords, 
    data = data.frame(grid),
    proj4string = grid@proj4string)
colnames(grid@coords) <- colnames(pontos@coords)
```

```{r}
pred_ponto <- predict(vario_fit_error, newdata = grid, control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
sp::spplot(pred_ponto)
```


Argumento type: fazer a predição do sinal "signal" z, "response" se for y ou efeitos fixos "trend"
se quiser predizer erro de medida, y = z + e, então response - signal = erro
se tendência - predito = componente aleatório


Usar control.predict.georob(extended.output = TRUE)

```{r}
pred_ponto <- predict(
  vario_fit_error, newdata = grid, type= "response", signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
str(pred_ponto)

spplot(pred_ponto)
```

```{r}
at <- pred_ponto@data[, c("pred", "lower", "upper")] %>% range()
sp::spplot(pred_ponto, zcol = c("lower", "pred", "upper"), main = "prediction")
```

```{r}
sp::spplot(pred_ponto, zcol = 'se', main = "SE")
```

